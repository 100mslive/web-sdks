// @generated by protobuf-ts 2.9.4 with parameter long_type_string
// @generated from protobuf file "sessionstore.proto" (package "sessionstorepb", syntax proto3)
// tslint:disable
import type {
  BinaryReadOptions,
  BinaryWriteOptions,
  IBinaryReader,
  IBinaryWriter,
  PartialMessage,
} from '@protobuf-ts/runtime';
import { MessageType, UnknownFieldHandler, WireType, reflectionMergePartial } from '@protobuf-ts/runtime';
import { ServiceType } from '@protobuf-ts/runtime-rpc';
/**
 * @generated from protobuf message sessionstorepb.HelloRequest
 */
export interface HelloRequest {
  /**
   * @generated from protobuf field: string name = 1;
   */
  name: string;
}
/**
 * @generated from protobuf message sessionstorepb.HelloResponse
 */
export interface HelloResponse {
  /**
   * @generated from protobuf field: string response = 1;
   */
  response: string;
}
/**
 * @generated from protobuf message sessionstorepb.SubscribeRequest
 */
export interface SubscribeRequest {
  /**
   * @generated from protobuf field: string name = 1;
   */
  name: string;
  /**
   * @generated from protobuf field: int64 offset = 2;
   */
  offset: string;
}
/**
 * @generated from protobuf message sessionstorepb.Event
 */
export interface Event {
  /**
   * @generated from protobuf field: string message = 1;
   */
  message: string;
  /**
   * @generated from protobuf field: int64 sequence = 2;
   */
  sequence: string;
}
/**
 * define new structure for value based on client needs and add support in
 * following message
 *
 * @generated from protobuf message sessionstorepb.Value
 */
export interface Value {
  /**
   * @generated from protobuf field: sessionstorepb.Value.Type type = 1;
   */
  type: Value_Type;
  /**
   * @generated from protobuf oneof: Data
   */
  data:
    | {
        oneofKind: 'number';
        /**
         * @generated from protobuf field: int64 number = 2;
         */
        number: string;
      }
    | {
        oneofKind: 'float';
        /**
         * @generated from protobuf field: float float = 3;
         */
        float: number;
      }
    | {
        oneofKind: 'str';
        /**
         * @generated from protobuf field: string str = 4;
         */
        str: string;
      }
    | {
        oneofKind: 'rawBytes';
        /**
         * @generated from protobuf field: bytes raw_bytes = 5;
         */
        rawBytes: Uint8Array;
      }
    | {
        oneofKind: undefined;
      };
}
/**
 * @generated from protobuf enum sessionstorepb.Value.Type
 */
export enum Value_Type {
  /**
   * @generated from protobuf enum value: NONE = 0;
   */
  NONE = 0,
  /**
   * @generated from protobuf enum value: BYTES = 1;
   */
  BYTES = 1,
  /**
   * @generated from protobuf enum value: STRING = 2;
   */
  STRING = 2,
  /**
   * @generated from protobuf enum value: INTEGER = 3;
   */
  INTEGER = 3,
  /**
   * @generated from protobuf enum value: FLOAT = 4;
   */
  FLOAT = 4,
}
/**
 * @generated from protobuf message sessionstorepb.GetRequest
 */
export interface GetRequest {
  /**
   * @generated from protobuf field: string key = 1;
   */
  key: string;
}
/**
 * @generated from protobuf message sessionstorepb.GetResponse
 */
export interface GetResponse {
  /**
   * @generated from protobuf field: string key = 1;
   */
  key: string;
  /**
   * @generated from protobuf field: string namespace = 2;
   */
  namespace: string;
  /**
   * @generated from protobuf field: sessionstorepb.Value value = 3;
   */
  value?: Value;
}
/**
 * @generated from protobuf message sessionstorepb.DeleteRequest
 */
export interface DeleteRequest {
  /**
   * @generated from protobuf field: string key = 1;
   */
  key: string;
}
/**
 * @generated from protobuf message sessionstorepb.DeleteResponse
 */
export interface DeleteResponse {}
/**
 * @generated from protobuf message sessionstorepb.SetRequest
 */
export interface SetRequest {
  /**
   * @generated from protobuf field: string key = 1;
   */
  key: string;
  /**
   * @generated from protobuf field: sessionstorepb.Value value = 3;
   */
  value?: Value;
}
/**
 * @generated from protobuf message sessionstorepb.SetResponse
 */
export interface SetResponse {}
/**
 * @generated from protobuf message sessionstorepb.ChangeStream
 */
export interface ChangeStream {
  /**
   * @generated from protobuf field: string change_id = 1;
   */
  changeId: string;
  /**
   * @generated from protobuf field: string key = 2;
   */
  key: string;
  /**
   * @generated from protobuf field: string namespace = 3;
   */
  namespace: string;
  /**
   * @generated from protobuf field: sessionstorepb.Value value = 4;
   */
  value?: Value;
  /**
   * @generated from protobuf field: string from_id = 5;
   */
  fromId: string;
}
/**
 * @generated from protobuf message sessionstorepb.Select
 */
export interface Select {
  /**
   * @generated from protobuf oneof: match
   */
  match:
    | {
        oneofKind: 'all';
        /**
         * @generated from protobuf field: string all = 1;
         */
        all: string; // match all keys
      }
    | {
        oneofKind: 'key';
        /**
         * @generated from protobuf field: string key = 2;
         */
        key: string; // match key
      }
    | {
        oneofKind: 'prefix';
        /**
         * @generated from protobuf field: string prefix = 3;
         */
        prefix: string; // match keys with given prefix
      }
    | {
        oneofKind: 'suffix';
        /**
         * @generated from protobuf field: string suffix = 4;
         */
        suffix: string; // match keys with given suffix
      }
    | {
        oneofKind: undefined;
      };
}
/**
 * @generated from protobuf message sessionstorepb.OpenRequest
 */
export interface OpenRequest {
  /**
   * last received change_id for reconnection, "" if first connection
   *
   * @generated from protobuf field: string change_id = 1;
   */
  changeId: string;
  /**
   * @generated from protobuf field: repeated sessionstorepb.Select select = 3;
   */
  select: Select[];
}
/**
 * @generated from protobuf message sessionstorepb.CountRequest
 */
export interface CountRequest {}
/**
 * @generated from protobuf message sessionstorepb.CountResponse
 */
export interface CountResponse {
  /**
   * @generated from protobuf field: int64 count = 1;
   */
  count: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class HelloRequest$Type extends MessageType<HelloRequest> {
  constructor() {
    super('sessionstorepb.HelloRequest', [{ no: 1, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }]);
  }
  create(value?: PartialMessage<HelloRequest>): HelloRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.name = '';
    if (value !== undefined) reflectionMergePartial<HelloRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: HelloRequest,
  ): HelloRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */ 1:
          message.name = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: HelloRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* string name = 1; */
    if (message.name !== '') writer.tag(1, WireType.LengthDelimited).string(message.name);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message sessionstorepb.HelloRequest
 */
export const HelloRequest = new HelloRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HelloResponse$Type extends MessageType<HelloResponse> {
  constructor() {
    super('sessionstorepb.HelloResponse', [{ no: 1, name: 'response', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }]);
  }
  create(value?: PartialMessage<HelloResponse>): HelloResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.response = '';
    if (value !== undefined) reflectionMergePartial<HelloResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: HelloResponse,
  ): HelloResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string response */ 1:
          message.response = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: HelloResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* string response = 1; */
    if (message.response !== '') writer.tag(1, WireType.LengthDelimited).string(message.response);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message sessionstorepb.HelloResponse
 */
export const HelloResponse = new HelloResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeRequest$Type extends MessageType<SubscribeRequest> {
  constructor() {
    super('sessionstorepb.SubscribeRequest', [
      { no: 1, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'offset', kind: 'scalar', T: 3 /*ScalarType.INT64*/ },
    ]);
  }
  create(value?: PartialMessage<SubscribeRequest>): SubscribeRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.name = '';
    message.offset = '0';
    if (value !== undefined) reflectionMergePartial<SubscribeRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SubscribeRequest,
  ): SubscribeRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */ 1:
          message.name = reader.string();
          break;
        case /* int64 offset */ 2:
          message.offset = reader.int64().toString();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: SubscribeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* string name = 1; */
    if (message.name !== '') writer.tag(1, WireType.LengthDelimited).string(message.name);
    /* int64 offset = 2; */
    if (message.offset !== '0') writer.tag(2, WireType.Varint).int64(message.offset);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message sessionstorepb.SubscribeRequest
 */
export const SubscribeRequest = new SubscribeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Event$Type extends MessageType<Event> {
  constructor() {
    super('sessionstorepb.Event', [
      { no: 1, name: 'message', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'sequence', kind: 'scalar', T: 3 /*ScalarType.INT64*/ },
    ]);
  }
  create(value?: PartialMessage<Event>): Event {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.message = '';
    message.sequence = '0';
    if (value !== undefined) reflectionMergePartial<Event>(this, message, value);
    return message;
  }
  internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Event): Event {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string message */ 1:
          message.message = reader.string();
          break;
        case /* int64 sequence */ 2:
          message.sequence = reader.int64().toString();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: Event, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* string message = 1; */
    if (message.message !== '') writer.tag(1, WireType.LengthDelimited).string(message.message);
    /* int64 sequence = 2; */
    if (message.sequence !== '0') writer.tag(2, WireType.Varint).int64(message.sequence);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message sessionstorepb.Event
 */
export const Event = new Event$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Value$Type extends MessageType<Value> {
  constructor() {
    super('sessionstorepb.Value', [
      { no: 1, name: 'type', kind: 'enum', T: () => ['sessionstorepb.Value.Type', Value_Type] },
      { no: 2, name: 'number', kind: 'scalar', oneof: 'data', T: 3 /*ScalarType.INT64*/ },
      { no: 3, name: 'float', kind: 'scalar', oneof: 'data', T: 2 /*ScalarType.FLOAT*/ },
      { no: 4, name: 'str', kind: 'scalar', oneof: 'data', T: 9 /*ScalarType.STRING*/ },
      { no: 5, name: 'raw_bytes', kind: 'scalar', oneof: 'data', T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<Value>): Value {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.type = 0;
    message.data = { oneofKind: undefined };
    if (value !== undefined) reflectionMergePartial<Value>(this, message, value);
    return message;
  }
  internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Value): Value {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* sessionstorepb.Value.Type type */ 1:
          message.type = reader.int32();
          break;
        case /* int64 number */ 2:
          message.data = {
            oneofKind: 'number',
            number: reader.int64().toString(),
          };
          break;
        case /* float float */ 3:
          message.data = {
            oneofKind: 'float',
            float: reader.float(),
          };
          break;
        case /* string str */ 4:
          message.data = {
            oneofKind: 'str',
            str: reader.string(),
          };
          break;
        case /* bytes raw_bytes */ 5:
          message.data = {
            oneofKind: 'rawBytes',
            rawBytes: reader.bytes(),
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: Value, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* sessionstorepb.Value.Type type = 1; */
    if (message.type !== 0) writer.tag(1, WireType.Varint).int32(message.type);
    /* int64 number = 2; */
    if (message.data.oneofKind === 'number') writer.tag(2, WireType.Varint).int64(message.data.number);
    /* float float = 3; */
    if (message.data.oneofKind === 'float') writer.tag(3, WireType.Bit32).float(message.data.float);
    /* string str = 4; */
    if (message.data.oneofKind === 'str') writer.tag(4, WireType.LengthDelimited).string(message.data.str);
    /* bytes raw_bytes = 5; */
    if (message.data.oneofKind === 'rawBytes') writer.tag(5, WireType.LengthDelimited).bytes(message.data.rawBytes);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message sessionstorepb.Value
 */
export const Value = new Value$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRequest$Type extends MessageType<GetRequest> {
  constructor() {
    super('sessionstorepb.GetRequest', [{ no: 1, name: 'key', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }]);
  }
  create(value?: PartialMessage<GetRequest>): GetRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.key = '';
    if (value !== undefined) reflectionMergePartial<GetRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetRequest,
  ): GetRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string key */ 1:
          message.key = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: GetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* string key = 1; */
    if (message.key !== '') writer.tag(1, WireType.LengthDelimited).string(message.key);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message sessionstorepb.GetRequest
 */
export const GetRequest = new GetRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetResponse$Type extends MessageType<GetResponse> {
  constructor() {
    super('sessionstorepb.GetResponse', [
      { no: 1, name: 'key', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'namespace', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'value', kind: 'message', T: () => Value },
    ]);
  }
  create(value?: PartialMessage<GetResponse>): GetResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.key = '';
    message.namespace = '';
    if (value !== undefined) reflectionMergePartial<GetResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetResponse,
  ): GetResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string key */ 1:
          message.key = reader.string();
          break;
        case /* string namespace */ 2:
          message.namespace = reader.string();
          break;
        case /* sessionstorepb.Value value */ 3:
          message.value = Value.internalBinaryRead(reader, reader.uint32(), options, message.value);
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: GetResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* string key = 1; */
    if (message.key !== '') writer.tag(1, WireType.LengthDelimited).string(message.key);
    /* string namespace = 2; */
    if (message.namespace !== '') writer.tag(2, WireType.LengthDelimited).string(message.namespace);
    /* sessionstorepb.Value value = 3; */
    if (message.value)
      Value.internalBinaryWrite(message.value, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message sessionstorepb.GetResponse
 */
export const GetResponse = new GetResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteRequest$Type extends MessageType<DeleteRequest> {
  constructor() {
    super('sessionstorepb.DeleteRequest', [{ no: 1, name: 'key', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }]);
  }
  create(value?: PartialMessage<DeleteRequest>): DeleteRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.key = '';
    if (value !== undefined) reflectionMergePartial<DeleteRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DeleteRequest,
  ): DeleteRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string key */ 1:
          message.key = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: DeleteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* string key = 1; */
    if (message.key !== '') writer.tag(1, WireType.LengthDelimited).string(message.key);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message sessionstorepb.DeleteRequest
 */
export const DeleteRequest = new DeleteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteResponse$Type extends MessageType<DeleteResponse> {
  constructor() {
    super('sessionstorepb.DeleteResponse', []);
  }
  create(value?: PartialMessage<DeleteResponse>): DeleteResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<DeleteResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DeleteResponse,
  ): DeleteResponse {
    return target ?? this.create();
  }
  internalBinaryWrite(message: DeleteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message sessionstorepb.DeleteResponse
 */
export const DeleteResponse = new DeleteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRequest$Type extends MessageType<SetRequest> {
  constructor() {
    super('sessionstorepb.SetRequest', [
      { no: 1, name: 'key', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'value', kind: 'message', T: () => Value },
    ]);
  }
  create(value?: PartialMessage<SetRequest>): SetRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.key = '';
    if (value !== undefined) reflectionMergePartial<SetRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SetRequest,
  ): SetRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string key */ 1:
          message.key = reader.string();
          break;
        case /* sessionstorepb.Value value */ 3:
          message.value = Value.internalBinaryRead(reader, reader.uint32(), options, message.value);
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: SetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* string key = 1; */
    if (message.key !== '') writer.tag(1, WireType.LengthDelimited).string(message.key);
    /* sessionstorepb.Value value = 3; */
    if (message.value)
      Value.internalBinaryWrite(message.value, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message sessionstorepb.SetRequest
 */
export const SetRequest = new SetRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetResponse$Type extends MessageType<SetResponse> {
  constructor() {
    super('sessionstorepb.SetResponse', []);
  }
  create(value?: PartialMessage<SetResponse>): SetResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<SetResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SetResponse,
  ): SetResponse {
    return target ?? this.create();
  }
  internalBinaryWrite(message: SetResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message sessionstorepb.SetResponse
 */
export const SetResponse = new SetResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeStream$Type extends MessageType<ChangeStream> {
  constructor() {
    super('sessionstorepb.ChangeStream', [
      { no: 1, name: 'change_id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'key', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'namespace', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: 'value', kind: 'message', T: () => Value },
      { no: 5, name: 'from_id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<ChangeStream>): ChangeStream {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.changeId = '';
    message.key = '';
    message.namespace = '';
    message.fromId = '';
    if (value !== undefined) reflectionMergePartial<ChangeStream>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ChangeStream,
  ): ChangeStream {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string change_id */ 1:
          message.changeId = reader.string();
          break;
        case /* string key */ 2:
          message.key = reader.string();
          break;
        case /* string namespace */ 3:
          message.namespace = reader.string();
          break;
        case /* sessionstorepb.Value value */ 4:
          message.value = Value.internalBinaryRead(reader, reader.uint32(), options, message.value);
          break;
        case /* string from_id */ 5:
          message.fromId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: ChangeStream, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* string change_id = 1; */
    if (message.changeId !== '') writer.tag(1, WireType.LengthDelimited).string(message.changeId);
    /* string key = 2; */
    if (message.key !== '') writer.tag(2, WireType.LengthDelimited).string(message.key);
    /* string namespace = 3; */
    if (message.namespace !== '') writer.tag(3, WireType.LengthDelimited).string(message.namespace);
    /* sessionstorepb.Value value = 4; */
    if (message.value)
      Value.internalBinaryWrite(message.value, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    /* string from_id = 5; */
    if (message.fromId !== '') writer.tag(5, WireType.LengthDelimited).string(message.fromId);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message sessionstorepb.ChangeStream
 */
export const ChangeStream = new ChangeStream$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Select$Type extends MessageType<Select> {
  constructor() {
    super('sessionstorepb.Select', [
      { no: 1, name: 'all', kind: 'scalar', oneof: 'match', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'key', kind: 'scalar', oneof: 'match', T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'prefix', kind: 'scalar', oneof: 'match', T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: 'suffix', kind: 'scalar', oneof: 'match', T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<Select>): Select {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.match = { oneofKind: undefined };
    if (value !== undefined) reflectionMergePartial<Select>(this, message, value);
    return message;
  }
  internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Select): Select {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string all */ 1:
          message.match = {
            oneofKind: 'all',
            all: reader.string(),
          };
          break;
        case /* string key */ 2:
          message.match = {
            oneofKind: 'key',
            key: reader.string(),
          };
          break;
        case /* string prefix */ 3:
          message.match = {
            oneofKind: 'prefix',
            prefix: reader.string(),
          };
          break;
        case /* string suffix */ 4:
          message.match = {
            oneofKind: 'suffix',
            suffix: reader.string(),
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: Select, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* string all = 1; */
    if (message.match.oneofKind === 'all') writer.tag(1, WireType.LengthDelimited).string(message.match.all);
    /* string key = 2; */
    if (message.match.oneofKind === 'key') writer.tag(2, WireType.LengthDelimited).string(message.match.key);
    /* string prefix = 3; */
    if (message.match.oneofKind === 'prefix') writer.tag(3, WireType.LengthDelimited).string(message.match.prefix);
    /* string suffix = 4; */
    if (message.match.oneofKind === 'suffix') writer.tag(4, WireType.LengthDelimited).string(message.match.suffix);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message sessionstorepb.Select
 */
export const Select = new Select$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OpenRequest$Type extends MessageType<OpenRequest> {
  constructor() {
    super('sessionstorepb.OpenRequest', [
      { no: 1, name: 'change_id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'select', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Select },
    ]);
  }
  create(value?: PartialMessage<OpenRequest>): OpenRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.changeId = '';
    message.select = [];
    if (value !== undefined) reflectionMergePartial<OpenRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: OpenRequest,
  ): OpenRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string change_id */ 1:
          message.changeId = reader.string();
          break;
        case /* repeated sessionstorepb.Select select */ 3:
          message.select.push(Select.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: OpenRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* string change_id = 1; */
    if (message.changeId !== '') writer.tag(1, WireType.LengthDelimited).string(message.changeId);
    /* repeated sessionstorepb.Select select = 3; */
    for (let i = 0; i < message.select.length; i++)
      Select.internalBinaryWrite(message.select[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message sessionstorepb.OpenRequest
 */
export const OpenRequest = new OpenRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CountRequest$Type extends MessageType<CountRequest> {
  constructor() {
    super('sessionstorepb.CountRequest', []);
  }
  create(value?: PartialMessage<CountRequest>): CountRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined) reflectionMergePartial<CountRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CountRequest,
  ): CountRequest {
    return target ?? this.create();
  }
  internalBinaryWrite(message: CountRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message sessionstorepb.CountRequest
 */
export const CountRequest = new CountRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CountResponse$Type extends MessageType<CountResponse> {
  constructor() {
    super('sessionstorepb.CountResponse', [{ no: 1, name: 'count', kind: 'scalar', T: 3 /*ScalarType.INT64*/ }]);
  }
  create(value?: PartialMessage<CountResponse>): CountResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.count = '0';
    if (value !== undefined) reflectionMergePartial<CountResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CountResponse,
  ): CountResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 count */ 1:
          message.count = reader.int64().toString();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: CountResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* int64 count = 1; */
    if (message.count !== '0') writer.tag(1, WireType.Varint).int64(message.count);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message sessionstorepb.CountResponse
 */
export const CountResponse = new CountResponse$Type();
/**
 * @generated ServiceType for protobuf service sessionstorepb.Api
 */
export const Api = new ServiceType('sessionstorepb.Api', [
  { name: 'Hello', options: {}, I: HelloRequest, O: HelloResponse },
  { name: 'Subscribe', serverStreaming: true, options: {}, I: SubscribeRequest, O: Event },
]);
/**
 * @generated ServiceType for protobuf service sessionstorepb.Store
 */
export const Store = new ServiceType('sessionstorepb.Store', [
  { name: 'open', serverStreaming: true, options: {}, I: OpenRequest, O: ChangeStream },
  { name: 'get', options: {}, I: GetRequest, O: GetResponse },
  { name: 'set', options: {}, I: SetRequest, O: SetResponse },
  { name: 'delete', options: {}, I: DeleteRequest, O: DeleteResponse },
  { name: 'count', options: {}, I: CountRequest, O: CountResponse },
]);
